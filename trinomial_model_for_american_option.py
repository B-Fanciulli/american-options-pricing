# -*- coding: utf-8 -*-
"""Trinomial model for American option.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FLf1glv-j77ZREPZ0O-K7KQjNjwjSgnv
"""

# Implementation of Trinomial model for American option
import numpy as np

__author__ = "Bartolomeo Fanciulli"


def put_opt(x, K):
    """Instant return of a put option with strike K and underlying x."""
    return max(0, K - x)

def tri_pricing_US(g=put_opt, start=5, r=1/6, d=2/3, m=1, u=4/3, N=100):
    """
    Computes the American put option price using a trinomial model.

    Parameters:
    ----------
    g : function
        Payoff function, defaults to put option payoff.
    start : float
        Initial asset price.
    r : float
        Risk-free rate per period.
    d : float
        Downward movement factor.
    m : float
        Middle movement factor.
    u : float
        Upward movement factor.
    N : int
        Number of time steps.

    Returns:
    -------
    None
        Prints the price bounds (p- and p+).
    """
    S0 = start
    K = start * 8 / 9
    p_u = (1 + r - d) / (u - d)
    p_m = 0
    p_d = 1 - p_u
    p = np.array([p_u, p_m, p_d])
    q_u = (1 + r - m) / (u - m)
    q_m = 1 - q_u
    q_d = 0
    q = np.array([q_u, q_m, q_d])

    # Initialize option prices at maturity
    U_old_max = np.zeros((N + 1, N + 1))
    for k in range(N + 1):
        for l in range(N - k + 1):
            S = S0 * (u ** k) * (d ** l) * (m ** (N - (k + l)))
            U_old_max[k, l] = g(S, K)
    U_old_min = U_old_max.copy()

    # Backward induction to calculate option prices at earlier times
    for n in range(N - 1, -1, -1):
        U_new_max = np.zeros((n + 1, n + 1))
        U_new_min = np.zeros((n + 1, n + 1))
        for k in range(n + 1):
            for l in range(n - k + 1):
                M_1 = (
                    U_old_max[k + 1, l] * p_u +
                    U_old_max[k, l] * p_m +
                    U_old_max[k, l + 1] * p_d
                )
                M_2 = (
                    U_old_max[k + 1, l] * q_u +
                    U_old_max[k, l] * q_m +
                    U_old_max[k, l + 1] * q_d
                )
                m_1 = (
                    U_old_min[k + 1, l] * p_u +
                    U_old_min[k, l] * p_m +
                    U_old_min[k, l + 1] * p_d
                )
                m_2 = (
                    U_old_min[k + 1, l] * q_u +
                    U_old_min[k, l] * q_m +
                    U_old_min[k, l + 1] * q_d
                )
                S = S0 * (u ** k) * (d ** l) * (m ** (n - (k + l)))
                U_new_max[k, l] = max(g(S, K), max(M_1, M_2)/(1+r))
                U_new_min[k, l] = max(g(S, K), min(m_1, m_2)/(1+r))
        U_old_max = U_new_max
        U_old_min = U_new_min

    print(f"p-: {U_old_min[0, 0]}, p+: {U_old_max[0, 0]}")

tri_pricing_US()